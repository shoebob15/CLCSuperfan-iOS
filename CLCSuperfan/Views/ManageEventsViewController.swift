//
//  ManageEventsViewController.swift
//  CLCSuperfan
//
//  Created by Brennan Reinhard on 4/18/25.
//

import UIKit
import MapKit

class ManageEventsViewController: UIViewController, UITableViewDelegate, UITableViewDataSource, UIGestureRecognizerDelegate {
    
    // MARK: - outlets
    @IBOutlet weak var eventTable: UITableView!
    @IBOutlet weak var eventTitle: UITextField!
    @IBOutlet weak var eventCode: UITextField! // TODO: the secret "password" for redeeming events will eventually be autogenerated
    
    @IBOutlet weak var mapView: MKMapView!
    
    @IBOutlet weak var addButton: UIButton!
    
    @IBOutlet weak var datePicker: UIDatePicker!
    @IBOutlet weak var startTimePicker: UIDatePicker!
    @IBOutlet weak var stopTimePicker: UIDatePicker!
    
    @IBOutlet var gestureRecognizer: UITapGestureRecognizer!
    // MARK: - variables
    private var events = [Event]()
    
    private var selectedCoordinate = CLLocationCoordinate2D(latitude: 42.23708, longitude: -88.32256) // set default coords to clc
    
    private var selectedEvent: Event?
    private var selectedIndex: Int?
    
    let geocoder = CLGeocoder()
    
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        // make sure tapgesturerecognizer doesn't cancel taps in table
        gestureRecognizer.cancelsTouchesInView = false
        
        // set table delegates
        eventTable.delegate = self
        eventTable.dataSource = self
        
        
        
        // configure refresh control for table
        let refreshControl = UIRefreshControl()
        refreshControl.addTarget(self, action: #selector(refresh), for: .valueChanged)
        
        eventTable.refreshControl = refreshControl
        
        // setup mapview
        setupMapView()
        refreshMapView()
        
        refresh()
    }
    
    // MARK: - helpers
    @objc func refresh() {
        NetworkManager.shared.request(api: EventAPI.all) { (result: Result<[Event], NetworkError>) in
            switch result {
            case .success(let events):
                self.events = events
                DispatchQueue.main.async {
                    self.eventTable.reloadData()
                    self.eventTable.refreshControl?.endRefreshing()
                }
                
            case .failure(let error):
                print("error fetching events: \(error)")
            }
        }
    }
    
    // TODO: maybe change to cllocation extension later?
    func coordinateToName(_ coordinate: CLLocationCoordinate2D, completion: @escaping (String) -> Void) {
        let location = coordinate.toCLLocation()
        geocoder.reverseGeocodeLocation(location) { placemarks, error in
            if let error = error {
                print("geocoding error: \(error)")
                completion("Unknown Location")
                return
            }
            
            if let placemark = placemarks?.first {
                // try to use placemark's name, but if it doesn't exist then use city name
                let name = placemark.name ?? placemark.locality ?? "Unnamed Location"
                completion(name)
            } else {
                completion("Unknown Location")
            }
        }
    }
    
    // sets up UITapGestureRecognizer on the mapview
    func setupMapView() {
        let gesture = UITapGestureRecognizer(target: self, action: #selector(handleMapTapGesture))
        gesture.delegate = self
        mapView.addGestureRecognizer(gesture)
    }
    
    // refreshes map annotations and camera
    func refreshMapView() {
        // remove all annotations from map
        mapView.removeAnnotations(mapView.annotations)
        
        // add new annotation displaying currently selected event location
        let annotation = MKPointAnnotation()
        annotation.coordinate = selectedCoordinate
        mapView.addAnnotation(annotation)
        
        // set map camera to 1000m x 1000m area around point
        mapView.setRegion(
            MKCoordinateRegion(
                center: annotation.coordinate,
                latitudinalMeters: 1000,
                longitudinalMeters: 1000),
            animated: true)
    }
    
    // resets mapview, textfields, and date stuff
    func resetFields() {
        eventTitle.text = ""
        eventCode.text = ""
        selectedCoordinate = CLLocationCoordinate2D(latitude: 42.23708, longitude: -88.32256)
        datePicker.date = Date.now
        startTimePicker.date = Date.now
        stopTimePicker.date = Date.now
    }
    
    // handles tap gesture on map
    @objc func handleMapTapGesture(gesture: UITapGestureRecognizer) {
        let touchPoint = gesture.location(in: mapView)
        let coordinate = mapView.convert(touchPoint, toCoordinateFrom: mapView)
        
        selectedCoordinate = coordinate
        refreshMapView()
    }
    
    // MARK: - actions
    // add/edit event action
    @IBAction func addEvent(_ sender: UIButton) {
        let day = datePicker.date
        let start = startTimePicker.date
        let stop = stopTimePicker.date
        
        let combinedStart = combineDates(day, start)
        let combinedStop = combineDates(day, stop)
        
        debugPrint("start: \(combinedStart)")
        debugPrint("stop: \(combinedStop)")
        
        
        
        // edit mode
        if let event = selectedEvent, let index = selectedIndex {
            let newEvent = Event(
                id: event.id,
                name: eventTitle.text!,
                code: eventCode.text!,
                lat: selectedCoordinate.latitude,
                lon: selectedCoordinate.longitude,
                startTime: Int(combinedStart.timeIntervalSince1970),
                stopTime: Int(combinedStop.timeIntervalSince1970)
            )
            
            // reset vc after editing
            eventTable.deselectRow(at: IndexPath(row: selectedIndex!, section: 0), animated: true)
            
            resetFields()
            self.selectedEvent = nil
            self.selectedIndex = nil
            
            NetworkManager.shared.request(api: EventAPI.updateEvent(id: event.id.uuidString, event: newEvent)) { (result: Result<Event, NetworkError>) in
                switch result {
                case .success:
                    print("edited event")
                case .failure(let error):
                    print("error editing event: \(error)")
                }
                
                DispatchQueue.main.async {
                    self.refresh()
                }
            }
        } else {
            // create mode
            // disregard the client-generated uuid, since server manages ids
            let newEvent = Event(id: UUID(), name: eventTitle.text!, code: eventCode.text!, lat: selectedCoordinate.latitude, lon: selectedCoordinate.longitude, startTime: Int(combinedStart.timeIntervalSince1970),
                                 stopTime: Int(combinedStop.timeIntervalSince1970))
            
            NetworkManager.shared.request(api: EventAPI.createEvent(event: newEvent)) { (result: Result<Event, NetworkError>) in
                switch result {
                case .success:
                    print("created new event")
                case .failure(let error):
                    print("failed to create event, \(error)")
                }
                
                DispatchQueue.main.async {
                    self.refresh()
                }
            }
            
        }
        
        
    }
    
    // makes a new date with the ymd of d1 and the hms of d2
    func combineDates(_ d1: Date, _ d2: Date) -> Date {
        let calendar = Calendar.current
        
        let d1Comp = calendar.dateComponents([.year, .month, .day], from: d1)
        let d2Comp = calendar.dateComponents([.hour, .minute, .second, .nanosecond], from: d2)
        
        var combined = DateComponents()
        combined.year = d1Comp.year
        combined.month = d1Comp.month
        combined.day = d1Comp.day
        combined.hour = d2Comp.hour
        combined.minute = d2Comp.minute
        combined.second = d2Comp.second
        combined.nanosecond = d2Comp.nanosecond
        
        return calendar.date(from: combined)!
    }
    
    
    
    // MARK: - delegate funcs
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        events.count
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        let event = events[indexPath.row]
        
        let cell = eventTable.dequeueReusableCell(withIdentifier: "eventCell")!
        cell.textLabel!.text = event.name
        cell.detailTextLabel!.text = event.timeRange
        
        return cell
    }
    
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        print("selected")
        // set vc variables for selected row
        let event = events[indexPath.row]
        
        selectedEvent = event
        selectedIndex = indexPath.row
        
        
        // set text fields and map to be the selected row
        eventTitle.text = event.name
        eventCode.text = event.code
        
        // set date pickers
        datePicker.date = Date(timeIntervalSince1970: TimeInterval(event.startTime))
        startTimePicker.date = Date(timeIntervalSince1970: TimeInterval(event.startTime))
        stopTimePicker.date = Date(timeIntervalSince1970: TimeInterval(event.stopTime))
        
        selectedCoordinate = CLLocationCoordinate2D(latitude: event.lat, longitude: event.lon)
        refreshMapView()
        
        addButton.titleLabel!.text = "Edit"
    }
    
    // TODO: don't use deprecated functions
    func tableView(_ tableView: UITableView, editActionsForRowAt indexPath: IndexPath) -> [UITableViewRowAction]? {
        let deleteAction = UITableViewRowAction(style: .destructive, title: "Delete") { action, indexPath in
            NetworkManager.shared.request(api: EventAPI.deleteEvent(id: self.events[indexPath.row].id.uuidString)) { (result: Result<EmptyResponse, NetworkError>) in
                switch result {
                case .success(let deleted):
                    self.events.remove(at: indexPath.row)
                    
                    DispatchQueue.main.async {
                        self.eventTable.deleteRows(at: [indexPath], with: .automatic)
                    }
                    return
                case .failure(let error):
                    print("error deleting event, error: \(error)")
                }
            }
            
            self.selectedEvent = nil
            self.selectedIndex = nil
            
            DispatchQueue.main.async {
                self.resetFields()
                self.addButton.titleLabel!.text = "Add"
            }
            
            
        }
        
        return [deleteAction]
    }
    
    @IBAction func tapRecognized(_ sender: UITapGestureRecognizer) {
        eventTitle.resignFirstResponder()
        eventCode.resignFirstResponder()
    }
    
}

// quick extension to convert cllocationcoordinate2d to cllocation
extension CLLocationCoordinate2D {
    func toCLLocation() -> CLLocation {
        return CLLocation(latitude: latitude, longitude: longitude)
    }
}
